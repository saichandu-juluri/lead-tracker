import nodemailer from "nodemailer";
import { NextResponse } from "next/server";
import clientPromise from "@/app/lib/mongodb";
import { reqGroqAI } from "@/app/lib/groq";


const email = process.env.EMAIL;
const pass = process.env.EMAIL_PASS;

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: email,
    pass,
  },
});

// Function to generate email content dynamically using Groq API
const generateEmailContent = async (recipientEmail) => {
  const maxRetries = 5; // Maximum number of retries
  let attempt = 0;

  while (attempt < maxRetries) {
    try {
      // Send a prompt to reqGroqAI
      const chatCompletion = await reqGroqAI(`
        Generate a subject line and fill in the gaps in the email body below. Return only the JSON object as the output, without any extra text or explanation.

Email body:
Hi [name],

Nice to meet you yesterday. It is great to learn about [company name]. We know it is always challenging to [retain an audience for text campaigns], we would love to learn if you have similar or other challenges.

Gravitate AI provides highly customized AI solutioning and development services for businesses. Do you want to have a call to discuss if we can augment your AI capabilities and improve your product and services?

At the end, add: "**Generated by AI**" (highlighted).

Return the result in this JSON format:
{
  "subject": "Subject line",
  "email": "Email body"
}
      `);

      // Extract and parse the response content
      const responseContent = chatCompletion.choices[0]?.message?.content || "";
      const jsonContent = JSON.parse(responseContent); // Attempt to parse JSON

      // Check if required fields exist in the JSON
      if (jsonContent.subject && jsonContent.email) {
        console.log(`Email content for ${recipientEmail}:`, jsonContent);
        return {
          json_content: jsonContent, // Return valid JSON content
        };
      } else {
        throw new Error("Invalid JSON structure");
      }
    } catch (error) {
      console.error(`Attempt ${attempt + 1} failed for ${recipientEmail}:`, error.message);
      attempt++;

      // Wait for a short delay before retrying (optional)
      await new Promise((resolve) => setTimeout(resolve, 1000)); // 1-second delay between retries
    }
  }

  // If all retries fail, return fallback/default content
  console.error(`All ${maxRetries} attempts failed for ${recipientEmail}. Using default content.`);
  return {
    json_content: {
      subject: "Default Subject",
      email: `Hi,

We encountered an issue generating your personalized email. Please reach out to us directly.

**Generated by AI, this email function can be changed accordingly**`,
    },
  };
};

export async function GET() {
  try {

    // Connect to MongoDB
    const client = await clientPromise;
    const db = client.db("test");

    // Fetch all users' emails from the database
    const users = await db.collection("conf_data").find({}, { projection: { email: 1, _id: 0 } }).toArray();

    // Extract email addresses
    const emailList = users.map((user) => user.email).filter(Boolean); // Ensure no null/undefined emails

    if (emailList.length === 0) {
      return NextResponse.json({ message: "No emails found in the database" }, { status: 404 });
    }

    console.log("Emails fetched:", emailList);

    // Send emails to all users (if required)
    for (const recipient of emailList) {
      const generatedContent = await generateEmailContent(recipient);
      const mailOptions = {
        from: email,
        to: recipient,
        subject: generatedContent.json_content.subject,
        text: generatedContent.json_content.email,
      };

      try {
        await transporter.sendMail(mailOptions);
        // console.log(`${generatedContent.text} Email sent successfully to ${recipient}`);
      } catch (err) {
        console.error(`Error sending email to ${recipient}:`, err);
      }
    }
    return NextResponse.json({ success: true, emailsSentTo: emailList }, { status: 200 });
   } catch (err) {
    console.error("Error sending email:", err);
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}